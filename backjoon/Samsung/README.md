



## backjoon - 17837

### Base

`변수 정보`

```shell
NxN 체스판 (4 <= N <= 12)
K개의 말 (4 <= K <= 10)
흰,빨,파 의 체스판 (0,1,2)
 →(R), ←(L), ↑(U), ↓(D) (1,2,3,4)
 행과 열번호는 1부터 시작

종료 조건은 어떤 말이든 4개가 쌓이는 말이 있을때 지나온 턴 리턴후 종료
```


`입력`

```shell
4 4   NxN
0 0 2 0  체스판에서의 색상 표시
0 0 1 0
0 0 1 2
0 2 0 0
2 1 1 - 1번 말 2행 2열 1(Right)
3 2 3 - 2번 말 3행 2열 3(Up)
2 2 1 - 3번 말 2행 2열 1(Right)
4 1 2 - 4번 말 4행 1열 2(Left)
```



`게임 방법`

입력으로 들어오는 말의 정보가 순서대로 말의 번호가 됨

위의 입력을 보면 처음 들어오는 말의 정보인 2 1 1 은 1번 말이 2행 1열에 있으며 1(RIGHT)방향으로 움직여야함을 뜻함

체스판의 색깔인 흰 빨 파는 각각의 의미가 있음.
각 체스판의 색상의 효과는 이동하려는 칸에 대한 설명임
* 흰색
  A말이 이동 하려는 칸이 흰색이라면 A가 현재 쌓고 있는 말들을 포함 해당 칸으로 이동하고 이동하려던 흰칸에 이미 말이 있는 경우 A스택을 위에 올린다.  
  ex) ABC -> EF => EFABC

* 빨간색
  A의 말 스택이 이동하려는 칸의 색상이 빨간색이라면, 이동후에 A말의 스택을 뒤집는다.  
  * 이동하려는 칸이 비어 있는 경우  
    ex) ABC -> 0 => CBA  

  * 이동하려는 칸이 비어 있지 않은 경우(A스택만 뒤집는다.)  
    ex) ABC -> FG => FGCBA

* 파란색  
  A의 말 스택이 이동하려는 칸의 생상이 파란색 인경우 이동 방향을 뒤집고 한칸 이동한다.  
  * 이동하려는 칸이 파란색인 경우  
    이동하지 않고 가만히 있는다.  
    ex) 4,1(오른쪽) 4,2(파란색) => 4,1(왼쪽) 

  * 이동하려는 칸이 체스판을 벗어나는 경우  
    이동하지 않고 가만히 있는다.  
    ex) 4,1(왼쪽) 4,0은 체스판을 벗어남 => 4,1(오른쪽)

1턴 이라 함은 모든 말이 각자의 번호 순서로 이동을 완료 했을때 1턴이 끝났다고 표현함.

만약 1000의 턴 동안 게임이 종료되지 안을시에는 -1이 리턴됨

### SOL

#### 시도

1. 말의 스택을 리스트로 표현

2. 말의 스택을 3차원 배열을 통해 표현

3. 말의 스택을 비트 연산을 통해 표현  
    예를 들어 말이 345가 스택으로 쌓여있다고 생각 했을때 이를 비트로 표현해 준다.
    ```c
    int chessmensA=0x0345;
    ```
    이를 체크해 주기 위해
    비트 연산을 해준다.
    예를 들어 스택에서의 3의 위치를 찾고자 할때
    ```c
    int chessmenThree=0x3;
    for(i=1; i<4;i++){
      if(chessmensA&(chessmenThree<<(i*4))){
        printf("Chessmen 3 [%d] stack\n",i);
      }
    }
    ```